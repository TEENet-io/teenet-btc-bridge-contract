// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.20;

import "./twbtc.sol";
import "./errors.sol";
import {Bip340Ecrec} from "./bip340-solidity@5a25f70/Bip340Ecrec.sol";

contract TEENetBtcBridge is ITEENetBtcBridgeErrors {
    /// @notice Public key of the secret that is generated by the threshold
    ///         Schnorr signature scheme. The partial secrets are used by
    ///         bridge nodes to perform an m-out-of-n threshold signature.
    uint256 private _pk;

    /// @notice Address of the deployed TWBTC contract
    address private _twbtc;

    /// @notice Address of the deployed bip340-solidity library
    address private _bip340;

    /// @notice Mapping to keep track of minted TWBTC tokens
    mapping(bytes32 => bool) private _minted;

    /// @notice Mapping to keep track of prepared redeem requests
    mapping(bytes32 => bool) private _prepared;

    event Minted(bytes32 indexed btcTxId, address receiver, uint256 amount);
    event RedeemRequested(address sender, uint256 amount, string receiver);
    event RedeemPrepared(
        bytes32 indexed ethTxHash,
        address requester,
        string receiver,
        uint256 amount,
        bytes32[] outpointTxIds,
        uint16[] outpointIdxs
    );

    constructor(uint256 pk_) {
        _pk = pk_;

        /// @dev    Set the deployed bridge as the owner of the TWBTC contract
        _twbtc = address(new TWBTC(address(this)));

        /// @dev    Deploy the Bip340Ecrec contract
        _bip340 = address(new Bip340Ecrec());
    }

    /// @notice Get the registered public key
    function pk() public view returns (uint256) {
        return _pk;
    }

    /// @notice Get the deployed TWBTC contract address
    function twbtc() public view returns (address) {
        return _twbtc;
    }

    function bip340() public view returns (address) {
        return _bip340;
    }

    /// @notice Mint TWBTC tokens and transfer to the receiver.
    ///         It requires a valid Schnorr signature generated
    ///         by m (out of n) bridge nodes via the threshold
    ///         Schnorr signature scheme.
    /// @dev    The Schnorr signature is performed on
    ///
    ///             keccak256(btcTxId||receiver||amount)
    ///
    ///         Function abi.encodePacked is used to do concatenation.
    /// @param  btcTxId ID of the Bitcoin transaction that transfers the funds
    ///         to the bridge BTC wallet
    /// @param  receiver Receiver ETH address
    /// @param  amount Amount of TWBTC to be minted
    /// @param  rx partial Schnorr signature
    /// @param  s partial Schnorr signature
    function mint(
        bytes32 btcTxId,
        address receiver,
        uint256 amount,
        uint256 rx,
        uint256 s
    ) public {
        if (receiver == address(0)) {
            revert ZeroEthAddress();
        }

        if (amount == 0) {
            revert ZeroAmount();
        }

        if (_minted[btcTxId]) {
            revert AlreadyMinted(btcTxId);
        }

        // Verify the threshold Schnorr signature
        if (
            !Bip340Ecrec(_bip340).verify(
                _pk,
                rx,
                s,
                keccak256(abi.encodePacked(btcTxId, receiver, amount))
            )
        ) {
            revert InvalidSchnorrSignature(btcTxId, receiver, amount, rx, s);
        }

        // Mint the TWBTC tokens
        TWBTC(_twbtc).mint(receiver, amount);

        // Mark the btcTxId as minted
        _minted[btcTxId] = true;

        emit Minted(btcTxId, receiver, amount);
    }

    /// @notice Request to redeem BTC. It emits an event to notify bridge
    /// nodes and burn TWBTC tokens. The function is performed by users who
    /// want to redeem BTC.
    /// @param  amount Amount of BTC to be redeemed (in satoshi)
    /// @param  receiver Receivers's BTC address
    function redeemRequest(uint256 amount, string memory receiver) public {
        if (amount == 0) {
            revert ZeroAmount();
        }

        TWBTC(_twbtc).burnFrom(msg.sender, amount);

        emit RedeemRequested(msg.sender, amount, receiver);
    }

    /// @notice Prepare to redeem BTC. The function is performed by bridge
    ///         nodes via m-out-of-n threshold Schnorr signature scheme.
    ///         After the bridge nodes observe the redeem request, they look
    ///         for outpoints referring to some spendable BTC coins and reserve
    ///         them to construct the future BTC tx that executes the redeem.
    ///         They then record the outpoints within the bridge contract to
    ///         enforce the construction of the tx so that the bridge nodes can
    ///         avoid sending multiple BTC txs for the same redeem request.
    /// @dev    The Schnorr signature is performed on
    ///
    ///             keccak256(redeemRequestTxHash||requester||amount||
    ///                 outpointTxIds||outpointIdxs)
    ///
    ///         Function abi.encodePacked is used to do concatenation.
    ///
    /// @param  redeemRequestTxHash Hash of the tx that sent by the user to
    ///         request redeem btc
    /// @param  requester Address of the user who requested to redeem BTC
    /// @param  receiver Receiver's BTC address
    /// @param  amount Amount of btc to be redeemed (in satoshi)
    /// @param  outpointTxIds outpoint BTC coins' tx ids
    /// @param  outpointIdxs outpoint BTC coins' output indexes
    /// @param  rx partial Schnorr signature
    /// @param  s partial Schnorr signature
    ///
    function redeemPrepare(
        bytes32 redeemRequestTxHash,
        address requester,
        string memory receiver,
        uint256 amount,
        bytes32[] memory outpointTxIds,
        uint16[] memory outpointIdxs,
        uint256 rx,
        uint256 s
    ) public {
        if (redeemRequestTxHash == 0) {
            revert ZeroEthTxHash();
        }

        if (_prepared[redeemRequestTxHash]) {
            revert AlreadyPrepared(redeemRequestTxHash);
        }

        if (requester == address(0)) {
            revert ZeroEthAddress();
        }

        if (bytes(receiver).length == 0) {
            revert EmptyString();
        }

        if (amount == 0) {
            revert ZeroAmount();
        }

        if (outpointTxIds.length == 0) {
            revert EmptyOutpointTxIds();
        }

        if (outpointIdxs.length == 0) {
            revert EmptyOutpointIdxs();
        }

        if (outpointTxIds.length != outpointIdxs.length) {
            revert OutpointTxIdsAndOutpointIdxsLengthMismatch();
        }

        for (uint16 i = 0; i < outpointTxIds.length; i++) {
            if (outpointTxIds[i] == 0) {
                revert ZeroOutpointTxId();
            }
        }

        if (
            !Bip340Ecrec(_bip340).verify(
                _pk,
                rx,
                s,
                keccak256(
                    abi.encodePacked(
                        redeemRequestTxHash,
                        requester,
                        receiver,
                        amount,
                        outpointTxIds,
                        outpointIdxs
                    )
                )
            )
        ) {
            revert InvalidSchnorrSignature(
                redeemRequestTxHash,
                requester,
                amount,
                rx,
                s
            );
        }

        _prepared[redeemRequestTxHash] = true;

        emit RedeemPrepared(
            redeemRequestTxHash,
            requester,
            receiver,
            amount,
            outpointTxIds,
            outpointIdxs
        );
    }

    /// @notice Check if TWBTC token are minted
    /// @param  btcTxId ID of the Bitcoin transaction that transfers the funds
    ///         to the bridge BTC wallet
    /// @return bool
    function isMinted(bytes32 btcTxId) public view returns (bool) {
        return _minted[btcTxId];
    }

    /// @notice Check if the redeem request is prepared
    /// @param  txHash Hash of the redeem request tx
    /// @return bool
    function isPrepared(bytes32 txHash) public view returns (bool) {
        return _prepared[txHash];
    }
}
