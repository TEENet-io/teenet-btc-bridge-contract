// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.20;

import "./twbtc.sol";
import "./errors.sol";
import {Bip340Ecrec} from "./bip340-solidity@5a25f70/Bip340Ecrec.sol";   

contract TEENetBtcEvmBridge is ITEENetBtcEvmBridgeErrors {
    /// @notice Public key of the secret that is generated by the threshold 
    ///         Schnorr signature scheme. The partial secrets are used by 
    ///         bridge nodes to perform an m-out-of-n threshold signature.
    uint256 private _pk;

    /// @notice Address of the deployed TWBTC contract
    address private _twbtc;

    /// @notice Address of the deployed bip340-solidity library
    address private _bip340;

    event Minted(
        bytes32 indexed btcTxId,
        address indexed receiver,
        uint256 indexed amount
    );
    event RedeemRequested(
        address indexed sender,
        uint256 indexed amount,
        string indexed receiver
    );
    event RedeemPrepared(
        bytes32 indexed evmTxHash,
        address requester,
        uint256 amount,
        bytes32[] spendableTxIds,
        uint16[] spendableIdxs
    );

    constructor(uint256 pk_) {
        _pk = pk_;

        /// @dev    Set the deployed bridge as the owner of the TWBTC contract
        _twbtc = address(new TWBTC(address(this)));

        /// @dev    Deploy the Bip340Ecrec contract
        _bip340 = address(new Bip340Ecrec());
    }

    /// @notice Get the registered public key
    function pk() public view returns (uint256) {
        return _pk;
    }

    /// @notice Get the deployed TWBTC contract address
    function twbtc() public view returns (address) {
        return _twbtc;
    }

    function bip340() public view returns (address) {
        return _bip340;
    }

    /// @notice Mint TWBTC tokens and transfer to the receiver.
    ///         It requires a valid Schnorr signature generated 
    ///         by m (out of n) bridge nodes via the threshold 
    ///         Schnorr signature scheme.
    /// @dev    The Schnorr signature is performed on 
    /// 
    ///             keccak256(btcTxId||receiver||amount)
    /// 
    ///         Function abi.encodePacked is used to do concatenation.
    /// @param  btcTxId ID of the Bitcoin transaction that transfers the funds 
    ///         to the bridge BTC wallet
    /// @param  receiver Receiver EVM address
    /// @param  amount Amount of TWBTC to be minted
    /// @param  rx partial Schnorr signature
    /// @param  s partial Schnorr signature
    function mint(
        bytes32 btcTxId,
        address receiver,
        uint256 amount,
        uint256 rx,
        uint256 s
    ) public {
        if (receiver == address(0)) {
            revert ZeroEvmAddress();
        }

        if (amount == 0) {
            revert ZeroAmount();
        }

        // Verify the threshold Schnorr signature
        if (
            !Bip340Ecrec(_bip340).verify(
                _pk,
                rx,
                s,
                keccak256(abi.encodePacked(btcTxId, receiver, amount))
            )
        ) {
            revert InvalidSchnorrSignature(btcTxId, receiver, amount, rx, s);
        }

        // Mint the TWBTC tokens
        TWBTC(_twbtc).mint(receiver, amount);

        emit Minted(btcTxId, receiver, amount);
    }

    /// @notice Request to redeem BTC. It only emits an event to notify bridge 
    /// nodes. The function is performed by users who want to redeem BTC.
    /// @param  amount Amount of BTC to be redeemed (in satoshi)
    /// @param  receiver Receivers's BTC address
    function redeemRequest(uint256 amount, string memory receiver) public {
        if (amount == 0) {
            revert ZeroAmount();
        }

        _checkBalance(msg.sender, amount);

        emit RedeemRequested(msg.sender, amount, receiver);
    }

    /// @notice Prepare to redeem BTC. The function is performed by bridge 
    ///         nodes via m-out-of-n threshold Schnorr signature scheme.
    ///         After the bridge nodes observe the redeem request, they look 
    ///         for the spendable BTC coins that can be used to construct the 
    ///         BTC tx. They then record the spendables within the bridge 
    ///         contract to avoid sending multiple BTC txs for the same redeem 
    ///         request.
    /// @dev    The Schnorr signature is performed on 
    /// 
    ///             keccak256(redeemRequestTxHash||requester||amount||
    ///                 spendableTxIds||spendableIdxs)
    /// 
    ///         Function abi.encodePacked is used to do concatenation.
    ///
    /// @param  redeemRequestTxHash Hash of the tx that sent by the user to 
    ///         request redeem btc
    /// @param  requester Address of the user who requested to redeem BTC
    /// @param  amount Amount of btc to be redeemed (in satoshi)
    /// @param  spendableTxIds Spendable BTC coins' tx ids
    /// @param  spendableIdxs Spendable BTC coins' output indexes
    /// @param  rx partial Schnorr signature
    /// @param  s partial Schnorr signature
    ///
    function redeemPrepare(
        bytes32 redeemRequestTxHash,
        address requester,
        uint256 amount,
        bytes32[] memory spendableTxIds,
        uint16[] memory spendableIdxs,
        uint256 rx,
        uint256 s
    ) public {
        if (redeemRequestTxHash == 0) {
            revert ZeroEvmTxHash();
        }

        if(requester == address(0)) {
            revert ZeroEvmAddress();
        }

        if(amount == 0) {
            revert ZeroAmount();
        }

        if (spendableTxIds.length == 0) {
            revert ZeroSpendableTxIdsArrayLength();
        }

        if (spendableIdxs.length == 0) {
            revert ZeroSpendableIdxsArrayLength();
        }

        if (spendableTxIds.length != spendableIdxs.length) {
            revert SpendableTxIdsAndSpendableIdxsLengthMismatch();
        }

        for (uint16 i = 0; i < spendableTxIds.length; i++) {
            if (spendableTxIds[i] == 0) {
                revert ZeroSpendableTxId();
            }
        }

        if(!Bip340Ecrec(_bip340).verify(
            _pk,
            rx,
            s,
            keccak256(abi.encodePacked(redeemRequestTxHash, requester, amount, spendableTxIds, spendableIdxs))
        )) {
            revert InvalidSchnorrSignature(redeemRequestTxHash, requester, amount, rx, s);
        }

        TWBTC(_twbtc).burn(requester, amount);

        emit RedeemPrepared(redeemRequestTxHash, requester, amount, spendableTxIds, spendableIdxs);
    }

    function _checkBalance(address addr, uint256 amount) private view {
        uint256 balance = TWBTC(_twbtc).balanceOf(addr);
        if (balance < amount) {
            revert InsufficientBalance(addr, amount, balance);
        }
    }
}
