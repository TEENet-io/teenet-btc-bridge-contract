// SPDX-License-Identifier: GPL-3.0
pragma solidity ^0.8.20;

import "./twbtc.sol";
import "./errors.sol";
import {Bip340Ecrec} from "./bip340-solidity@5a25f70/Bip340Ecrec.sol";   

contract TEENetBtcEvmBridge is ITEENetBtcEvmBridgeErrors {
    /// @notice Public key of the secret that is generated by the threshold 
    ///         Schnorr signature scheme. The partial secrets are used by 
    ///         bridge nodes to perform an m-out-of-n threshold signature.
    uint256 private _pk;

    /// @notice Address of the deployed TWBTC contract
    address private _twbtc;

    /// @notice Address of the deployed bip340-solidity library
    address private _bip340;

    event Minted(
        bytes32 indexed btcTxId,
        address indexed receiver,
        uint256 indexed amount
    );
    event RedeemRequested(
        address indexed sender,
        uint256 indexed amount,
        string indexed receiver
    );
    event RedeemPrepared(
        bytes32 indexed evmTxHash,
        address requester,
        uint256 amount,
        bytes32[] outpointTxIds,
        uint16[] outpointIdxs
    );

    constructor(uint256 pk_) {
        _pk = pk_;

        /// @dev    Set the deployed bridge as the owner of the TWBTC contract
        _twbtc = address(new TWBTC(address(this)));

        /// @dev    Deploy the Bip340Ecrec contract
        _bip340 = address(new Bip340Ecrec());
    }

    /// @notice Get the registered public key
    function pk() public view returns (uint256) {
        return _pk;
    }

    /// @notice Get the deployed TWBTC contract address
    function twbtc() public view returns (address) {
        return _twbtc;
    }

    function bip340() public view returns (address) {
        return _bip340;
    }

    /// @notice Mint TWBTC tokens and transfer to the receiver.
    ///         It requires a valid Schnorr signature generated 
    ///         by m (out of n) bridge nodes via the threshold 
    ///         Schnorr signature scheme.
    /// @dev    The Schnorr signature is performed on 
    /// 
    ///             keccak256(btcTxId||receiver||amount)
    /// 
    ///         Function abi.encodePacked is used to do concatenation.
    /// @param  btcTxId ID of the Bitcoin transaction that transfers the funds 
    ///         to the bridge BTC wallet
    /// @param  receiver Receiver EVM address
    /// @param  amount Amount of TWBTC to be minted
    /// @param  rx partial Schnorr signature
    /// @param  s partial Schnorr signature
    function mint(
        bytes32 btcTxId,
        address receiver,
        uint256 amount,
        uint256 rx,
        uint256 s
    ) public {
        if (receiver == address(0)) {
            revert ZeroEvmAddress();
        }

        if (amount == 0) {
            revert ZeroAmount();
        }

        // Verify the threshold Schnorr signature
        if (
            !Bip340Ecrec(_bip340).verify(
                _pk,
                rx,
                s,
                keccak256(abi.encodePacked(btcTxId, receiver, amount))
            )
        ) {
            revert InvalidSchnorrSignature(btcTxId, receiver, amount, rx, s);
        }

        // Mint the TWBTC tokens
        TWBTC(_twbtc).mint(receiver, amount);

        emit Minted(btcTxId, receiver, amount);
    }

    /// @notice Request to redeem BTC. It emits an event to notify bridge 
    /// nodes and burn TWBTC tokens. The function is performed by users who 
    /// want to redeem BTC.
    /// @param  amount Amount of BTC to be redeemed (in satoshi)
    /// @param  receiver Receivers's BTC address
    function redeemRequest(uint256 amount, string memory receiver) public {
        if (amount == 0) {
            revert ZeroAmount();
        }

        TWBTC(_twbtc).burnFrom(msg.sender, amount);

        emit RedeemRequested(msg.sender, amount, receiver);
    }

    /// @notice Prepare to redeem BTC. The function is performed by bridge 
    ///         nodes via m-out-of-n threshold Schnorr signature scheme.
    ///         After the bridge nodes observe the redeem request, they look 
    ///         for outpoints referring to some spendable BTC coins and reserve 
    ///         them to construct the future BTC tx that executes the redeem. 
    ///         They then record the outpoints within the bridge contract to 
    ///         enforce the construction of the tx so that the bridge nodes can
    ///         avoid sending multiple BTC txs for the same redeem request.
    /// @dev    The Schnorr signature is performed on 
    /// 
    ///             keccak256(redeemRequestTxHash||requester||amount||
    ///                 outpointTxIds||outpointIdxs)
    /// 
    ///         Function abi.encodePacked is used to do concatenation.
    ///
    /// @param  redeemRequestTxHash Hash of the tx that sent by the user to 
    ///         request redeem btc
    /// @param  requester Address of the user who requested to redeem BTC
    /// @param  amount Amount of btc to be redeemed (in satoshi)
    /// @param  outpointTxIds outpoint BTC coins' tx ids
    /// @param  outpointIdxs outpoint BTC coins' output indexes
    /// @param  rx partial Schnorr signature
    /// @param  s partial Schnorr signature
    ///
    function redeemPrepare(
        bytes32 redeemRequestTxHash,
        address requester,
        uint256 amount,
        bytes32[] memory outpointTxIds,
        uint16[] memory outpointIdxs,
        uint256 rx,
        uint256 s
    ) public {
        if (redeemRequestTxHash == 0) {
            revert ZeroEvmTxHash();
        }

        if(requester == address(0)) {
            revert ZeroEvmAddress();
        }

        if(amount == 0) {
            revert ZeroAmount();
        }

        if (outpointTxIds.length == 0) {
            revert ZeroOutpointTxIdsArrayLength();
        }

        if (outpointIdxs.length == 0) {
            revert ZeroOutpointIdxsArrayLength();
        }

        if (outpointTxIds.length != outpointIdxs.length) {
            revert OutpointTxIdsAndOutpointIdxsLengthMismatch();
        }

        for (uint16 i = 0; i < outpointTxIds.length; i++) {
            if (outpointTxIds[i] == 0) {
                revert ZeroOutpointTxId();
            }
        }

        if(!Bip340Ecrec(_bip340).verify(
            _pk,
            rx,
            s,
            keccak256(abi.encodePacked(redeemRequestTxHash, requester, amount, outpointTxIds, outpointIdxs))
        )) {
            revert InvalidSchnorrSignature(redeemRequestTxHash, requester, amount, rx, s);
        }

        emit RedeemPrepared(redeemRequestTxHash, requester, amount, outpointTxIds, outpointIdxs);
    }
}
